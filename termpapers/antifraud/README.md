# Антифрод в банковских транзакциях

## Введение

Антифрод-система — это сервис, который получает банковские транзакции,
анализирует их и блокирует их при подозрении в мошенничестве.
Проверка на фрод производится по неким правилам, задаваемых и кастомизируемых в системе в любой момент времени.

## Цель работы

Создать работающий прототип антифрод-системы, способный:

- принимать транзакции
- применять правила/алгоритмы
- принимать решение о подозрительности транзакции
- сохранять результаты в базу данных
- визуализировать аналитику антифрода

## Постановка задачи

Студент должен реализовать следующие функциональные блоки:

### Сбор транзакций

#### Источники

Реализовать получение данных из источников:

- файл .csv
- HTTP
- Брокер сообщений

#### Генерация данных

В вашем проекте должны быть **файлы** с тестовыми/фейковыми данными для импорта в БД.

Помимо этого, БД должна пополняться данными из брокера сообщений (Kafka/RabbitMQ)
через запущенную в фоне программу для генерации транзакций, добавляюмых в брокер в **реальном времени**.

### Правила

> Могут быть кастомизированы на ваше усмотрение

Минимум 3 разных правил, например:

- Сумма транзакции > X
- N транзакций за X минут
- Страна транзакции изменилась за <1 мин
- Много отклонённых транзакций подряд
- Несколько попыток перевода/списания разной суммы за короткий интервал
- Чёрный список мерчантов

### Хранение

#### Примерные схемы

> Могут быть кастомизированы на ваше усмотрение

##### Транзакция

- `id` *UInt64* — уникальный ключ
- `transaction_id` *String* — UUID транзакции из внешней системы
- `created_at` *DateTime* — дата и время операции, как передано источником
- `account_id` *UInt64* - идентфикартор счета в банке
- `amount` *Decimal* — сумма транзакции
- `currency` *String* — валюта (RUB / USD / EUR)
- `merchant` *String* — название/идентификатор магазина/сервиса
- `country` *String* — ISO-код страны (RU/US/CA)
- `status` *String* — статус транзакции (APPROVED / PENDING / DECLINED)
- `payload` *String/JSON/blob* — необработанный JSON транзакции
- `ingested_at` *DateTime* — когда событие было получено системой
- `source` *String* — источник данных (kafka / http / csv)

##### Фрод-алерты

- `id` *UInt64* — идентифкатор алерта
- `transaction_id` *String* — идентификатор связанной транзакции
- `account_id` *UInt64* — идентификатор счета
- `*rule_code` *String* — правило, вызвавшее алерт
- `severity` *String* — LOW / MEDIUM / HIGH
- `description` *String* — описание причины
- `created_at` *DateTime* — когда алерт был создан
- `resolved` *UInt8* — статус (0 = не решён, 1 = закрыт)

#### Фрод-правило

- `id` *UInt32* — уникальный идентификатор правила
- `code` *String* — техническое имя правила (high_amount, geo_jump)
- `title` *String* — человекочитаемое название
- `description` *String* — подробное описание логики
- `threshold` *Float64* — пороговое значение (если применимо)
- `enabled` *UInt8* — включено правило или нет
- `severity` *String* — уровень серьёзности (LOW/MEDIUM/HIGH)
- `created_at` *DateTime* — дата регистрации правила

### REST API для взаимодействия с приложением

> Должен быть, **как минимум, 2 эндпоинта**.
> Можно добавлять и другие на свое усмотрение, например для удобства отладки или демонстрации работы.

#### Проверка транзакции

Добавляет транзакцию в систему и проверка производится сразу.

`POST /transactions`

Пример тела запроса

```json
{
  "transaction_id": "abc-123",
  "created_at": "2025-01-01T12:00:00Z",
  "account_id": 1001,
  "amount": 9500,
  "country": "RU",
  "merchant": "MEGAMARKET",
}
```

Пример ответа

```json
{
  "result": "FRAUD",
  "rules_triggered": ["high_amount"],
}
```

#### Получение транзакций

Получает всю доступную информацию о транзакциях по фильтрам, например, идентификатору, счёту, статусам, времени и др.

`GET /transactions?id=abc-123&accound_id=1001`

Пример ответа

```json
[
    {
        "transaction_id": "abc-123",
        "created_at": "2025-01-01T12:00:00Z",
        "account_id": 1001,
        "amount": 9500,
        "country": "RU",
        "merchant": "MEGAMARKET",
    },
]
```

### Мониторинг

Используйте [Prometheus](https://prometheus.io/), [Grafana](https://grafana.com/)
для настройки мониторинга работы сервиса и инфраструктуры.

> Метрики мониторинга могут быть кастомизированы на ваше усмотрение

Рекомендуется настроить

- RPS приложения, response time, latency
- График алертов фрода (можно без уведомлений)
- Использование ресурсов (CPU, оперативная и постоянная память, сеть)
- Статус компонентов системы (БД, брокеры и т.д.)

### ETL-пайплайн

> Может быть доработан на ваше усмотрение

Ожидается минимум 1 DAG в Airflow, который:

- загружает транзакции из источников
- чистит данные
- обновляет профили клиентов
- сохраняет агрегаты по дням
- формирует таблицу для аналитики

### Аналитический дашборд

#### Инструменты

- Apache Superset (предпочтительнее)
- Metabase
- Grafana (при большом желании)

#### Требования

- Количество транзакций по времени
- Количество срабатываний фрод-правил
- Топ-10 мерчантов по фроду
- Топ-10 счетов по фроду
- Пайчарт применимости правил (проценты)
- Heatmap по странам
- Счетчик заблокированных транзакция с динамикой по времени
- Счетчик "спасенных" денег

## Минимальные требования

- Тестовые данные
  - Сгенерировать не менее 200 000 транзакций
  - Допускается использовать, как мультивалютные, так и омнивалютные транзакции
  - У пользователя может быть несколько счетов
- Правила антифрода
  - Минимум 3 правила
  - Алгоритм и принцип работы каждого правила должны быть описаны в `README.md`.
- 3 источника данных
  - файлы
  - HTTP
  - брокер сообщений
- Хранилище
- ETL-пайплайн
- Витрины
- Аналитический дашборд
