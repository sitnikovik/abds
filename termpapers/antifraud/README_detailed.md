# Курсовой проект: Система антифрода для банковских транзакций

## 1. Цель проекта

Разработать прототип системы обнаружения потенциально мошеннических транзакций в банковском потоке. Студенты должны показать умение:

1. Моделировать предметную область (транзакции, клиенты, устройства, мерчанты).
2. Организовать получение и хранение данных (батч / стрим).
3. Реализовать базовые правила и как минимум один алгоритмический метод обнаружения аномалий или мошенничества.
4. Оценить качество (Precision / Recall / F1 / ROC-AUC или PR-AUC) и эксплуатационные метрики (latency, throughput, FP rate).
5. Подготовить техническую документацию (PDF) и защитить архитектурные решения.

## 2. Б изнес‑контекст

Банк обрабатывает платежные транзакции (POS, e-commerce, P2P переводы). Мошенничество приводит к прямым финансовым потерям и штрафам. Цель антифрода — быстро (в < 300 мс) вынести решение: пропустить, отклонить или отправить на ручную проверку. В прототипе допустимо смоделировать сокращённую схему решений: ALLOW / REVIEW / BLOCK.

## 3. Обязательные артефакты (Deliverables)

1. Код (любой ЯП) в репозитории / архиве с:
   - Скриптом генерации синтетических данных.
   - Модулем ingestion (например, продюсер → Kafka → ClickHouse или просто batch загрузка в БД / файлы).
   - Модулем feature engineering (онлайн + офлайн признаки).
   - Алгоритмом детекции (rules engine + ML/анализ аномалий).
   - Сервисом/скриптом realtime scoring (REST API, gRPC, CLI или consumer Kafka).
   - Логикой агрегирования статистик (скорость, распределения, счётчики).
   - Тестами (минимум 5 unit + 2 интеграционных сценария).
   - Инструкцией по запуску (README или отдельный run.md).
2. PDF‑отчёт (структура ниже).
3. Краткая презентация (можно внутри PDF или отдельно) с архитектурной схемой.
4. Рекомендации по продакшену и масштабированию.

## 4. Формат PDF‑документа (рекомендуемая структура)

1. Титульный лист: тема, автор, группа, дата.
2. Резюме (abstract) — 5–8 предложений.
3. Введение: проблема мошенничества, цели проекта.
4. Анализ предметной области: сущности, связи, типы атак.
5. Источники и модель данных: схема транзакции, дополнительные таблицы.
6. Архитектура: диаграммы (данные, компоненты, поток событий).
7. Feature Engineering: список признаков, методы агрегации (окна, скользящие метрики).
8. Алгоритмы: правила + выбранные ML / anomaly detection подходы.
9. Эксперименты: методика, train/validation split, метрики.
10. Результаты: таблицы метрик, графики ROC / PR, важность признаков.
11. Производительность: латентность, пропускная способность, оценка ресурсов.
12. Ограничения и риски: качество данных, адаптация к новым атакам.
13. Безопасность и конфиденциальность (PII, маскирование, доступы).
14. Мониторинг и поддержка: метрики, алёрты, логирование.
15. Выводы и дальнейшая работа.
16. Приложения: схемы БД, примеры JSON, конфиги.

## 5. Схема транзакции (минимальная модель)

Рекомендуемый базовый JSON / табличная запись:

```json
{
  "transaction_id": "uuid",
  "timestamp": "2025-11-17T12:34:56Z",
  "account_id": 123456,
  "card_id": 987654,
  "merchant_id": 34567,
  "mcc": 5411,
  "channel": "ecommerce",         // pos | atm | ecommerce | p2p
  "amount": 1599.75,
  "currency": "RUB",
  "geo_lat": 55.7512,
  "geo_lon": 37.6185,
  "ip_address": "203.0.113.10",
  "device_id": "dev-abc-123",
  "is_card_present": false,
  "was_3ds": true,
  "previous_success_tx_last_1h": 12,
  "avg_amount_last_7d": 820.4,
  "std_amount_last_7d": 150.7,
  "distance_from_last_tx_km": 423.6,
  "channel_velocity_5m": 4
}
```

## 6. Признаки (feature engineering) — ориентиры
Минимум 15 признаков, из них:
1. Raw: amount, channel, mcc, geo, device_id, card_present.
2. Агрегаты: среднее / медиана / std суммы за окна (5м, 1ч, 24ч, 7д).
3. Velocity: число транзакций за последние 30с / 5м / 1ч.
4. География: расстояние от предыдущей транзакции (Haversine) + скорость перемещения.
5. Device / IP novelty: встречался ли ранее (boolean / счетчик).
6. Модель риска мерчанта: частота chargeback по mcc/merchant.
7. Временные признаки: час суток, день недели, праздничный день.
8. Поведенческий профиль: отклонение суммы от среднего (z-score).

## 7. Типовые мошеннические паттерны (должны быть отражены в правилах)
1. Быстрые множественные транзакции (burst) у нового устройства.
2. Необычно большая сумма относительно истории клиента.
3. Географически невозможное перемещение (distance / time).
4. Несколько отказов подряд → успешная крупная транзакция.
5. Разбиение большой суммы на серию мелких (smurfing / split).
6. Транзакции в высокорисковых MCC.
7. Отсутствие 3DS при высокой сумме в e-commerce.
8. Новое устройство + новый IP + высокая сумма.

## 8. Алгоритмы (минимум 2 уровня)
1. Rule Engine (обязательно): набор if/threshold / score accumulator.
2. Один из подходов:
	 - Supervised: логистическая регрессия, XGBoost, CatBoost.
	 - Unsupervised: Isolation Forest, LOF, One-Class SVM.
	 - Semi-Supervised: Autoencoder reconstruction error.
	 - Streaming: скользящие окна + статистические тесты (например, z-score > k).
3. Дополнительно (повышенные баллы): графовые признаки (связи между account ↔ device ↔ ip ↔ merchant).

## 9. Метрики качества и эксплуатации
Обязательные:
1. Precision, Recall, F1.
2. ROC-AUC или PR-AUC (если сильно несбалансировано).
3. False Positive Rate (FP / All Legitimate).
4. Average Decision Latency (мс) и 95-ый перцентиль.
5. Throughput (txn/sec в тесте нагрузки).
6. Drift индикаторы (изменение распределений признаков).

## 10. Архитектурные требования (варианты реализации)
Выберите ОДИН основной сценарий и опишите обоснование:
1. Streaming: Producer → Kafka → Consumer (scoring) → Sink (ClickHouse / Postgres) + Alert Topic.
2. Micro-batch: каждые N минут формирование feature set → scoring → выгрузка.
3. Pure batch (минимум баллов): исторический scoring без realtime.

Рекомендуем использовать: Kafka (топик транзакций), ClickHouse (фичи + результаты), любую БД для справочников.

## 11. Структура кода (рекомендация, адаптируйте под свой ЯП)
```
project/
	data_gen/           # генерация синтетики
	ingestion/          # загрузка / продюсер
	features/           # вычисление признаков
	models/             # обучение и сериализация
	scoring_service/    # онлайн решение
	rules/              # правила антифрода
	evaluation/         # метрики и эксперименты
	docs/               # PDF источники / рисунки
	tests/              # unit + интеграционные
	docker/             # Dockerfile / compose (опц.)
```

## 12. Минимальные функциональные требования
1. Генерация ≥ 100k транзакций (несбалансированность мошенничества ~1–3%).
2. Реализация ≥ 6 правил + комбинированный скоринг.
3. Обучение хотя бы одной модели (если supervised — нужен синтетический label).
4. API или CLI для проверки единичной транзакции.
5. Сохранение решений (ALLOW / REVIEW / BLOCK) + причины (список сработавших правил).
6. Логи: входные данные, время обработки, итоговый скор.

## 13. Нефункциональные требования
1. Средняя latency < 300 мс (для онлайн режима) на наборе из ≥ 1000 транзакций.
2. Документировать точки расширения (добавление правил, смена модели, обновление признаков).
3. Повторяемость экспериментов (фиксированный random seed).

## 14. Оценивание (рубрика)
| Критерий | Баллы |
|----------|-------|
| Корректность предметной модели | 10 |
| Генерация данных и реализм распределений | 10 |
| Feature engineering (качество / разнообразие) | 15 |
| Правила + их обоснование | 10 |
| ML / Anomaly алгоритм | 15 |
| Метрики и интерпретация | 10 |
| Архитектура и код (структура, тесты) | 15 |
| Документация PDF | 10 |
| Защита (ответы на вопросы, аргументация) | 5 |
| Дополнительно: граф / drift / explainability | +10 (bonus) |

Максимум базово: 100, с бонусами: 110.

## 15. Вопросы к защите (готовьтесь ответить)
1. Почему выбраны именно такие признаки? Какие из них наиболее информативны?
2. Чем отличается Rule Engine от ML по возможностям и ограничениям?
3. Как уменьшать False Positives без потери Recall?
4. Что делать при появлении новой схемы атаки (zero-day)?
5. Как реализовать онлайн обновление модели?
6. Какой стратегией пользоваться при сильном дисбалансе классов?
7. Как мониторить деградацию качества (model drift / data drift)?
8. Как масштабировать компонент scoring при росте TPS ×10?
9. Какие риски приватности и соответствия требованиям (PII / GDPR)?
10. Как бы вы внедрили объяснимость (feature contribution, SHAP)?

## 16. Рекомендации по реализации
1. Начните с генератора данных (реалистичные распределения: логнормальная сумма, пик активности в 10–12 и 18–21 час, гео вокруг нескольких городов).
2. Реализуйте 2–3 простых правила → проверьте качество на синтетике.
3. Добавьте расчёт признаков (окна через rolling / агрегаты по ключам).
4. Обучите базовую модель (логистическая регрессия / дерево) на метках (симулируйте мошенничество: вставка шаблонных паттернов).
5. Сравните performance rule-only vs rule+ML.
6. Добавьте логирование причин (explain: RULE_X, RULE_Y, MODEL_SCORE>threshold).
7. Проведите нагрузочный тест (скрипт генерации N транзакций → время обработки).

## 17. Пример baseline правил (адаптируйте)
```text
RULE_1: amount > 5 * avg_amount_last_7d → + HighRisk
RULE_2: velocity (5m) > 10 для нового device_id → + MediumRisk
RULE_3: distance_from_last_tx_km > 1000 в < 30m → + HighRisk
RULE_4: mcc ∈ {7995, 4829, 6012} и amount > 90 перцентиля → + MediumRisk
RULE_5: is_card_present = false AND was_3ds = false AND amount > X → + HighRisk
RULE_6: channel = ecommerce AND ip_address новый AND amount > Y → + MediumRisk
```
Перевод скоринга в решение:
```text
score >= 3 → BLOCK
score = 2 → REVIEW
score <= 1 → ALLOW
```

## 18. Пример схемы оценки модели
```text
Train: 70%, Validation: 15%, Test: 15% (стратифицировано).
Оптимизация порога по максимизации F1 или заданному Recall (≥ 0.8).
Сравнение ROC-AUC rule-only vs rule+model.
```

## 19. Пример команд (если используете Kafka + ClickHouse)
```bash
# Генерация транзакций и отправка в Kafka
python data_gen/generate.py --count 100000 --out kafka

# Консьюмер с расчётом признаков и записью в ClickHouse
python ingestion/consume.py --brokers kafka:9092 --topic transactions --sink clickhouse

# Обучение модели
python models/train.py --input features.parquet --model-out model.bin

# Онлайн скоринг (REST)
uvicorn scoring_service.app:app --host 0.0.0.0 --port 8081

# Тест единичной транзакции
curl -X POST http://localhost:8081/score -d '{"amount": 1599.0, ... }'
```

## 20. Дополнительные идеи (для бонуса)
1. Drift detection: сравнение текущих гистограмм признаков с эталонными (PSI, KL divergence).
2. Explainability: SHAP / permutation importance.
3. Feature store: кэширование агрегатов в Redis.
4. Graph построение: device_id ↔ account_id ↔ ip_address (подозрительные кластеры).
5. Canary модель: параллельный запуск новой версии и сравнение метрик.

## 21. Качество оформления
1. Код: единый стиль, линтеры.
2. Комментарии только там, где не очевидно.
3. README: краткие шаги запуска.
4. PDF: без орфографических ошибок, единая терминология.
5. Диаграммы: понятные легенды.

## 22. Частые ошибки (избегайте)
1. Отсутствие стратификации при разбиении.
2. Смешивание train и test признаков (data leakage: агрегаты, содержащие будущие события).
3. Отсутствие базового сравнения (rules vs model).
4. Не указаны метрики latency.
5. Отсутствие интерпретации результатов (почему модель лучше?).

## 23. Итог
Цель — не идеально «поймать мошенников», а продемонстрировать умение построить воспроизводимый, расширяемый прототип антифрод системы с аргументированными решениями.

Удачи на защите! Подготовьте ответы на список вопросов и будьте готовы показать быстрый демо‑сценарий (5–10 транзакций с различными паттернами).

---
При необходимости можно адаптировать структуру: главное — прозрачность, воспроизводимость и обоснование.

